% Tail loading

function [L_interp_h, y_interp_h, L_h_interp,y_interp, L_v_interp] = TailLoading(i_t_h, span_h, C_r_h, t_h, C_L_alpha_h, AR_h, S_h, S_v, span_v, C_r_v, t_v, i_v, AR_v, C_t_h, C_t_v, alpha_h)

%% Horizontal Tail
% Lifting line theory

N = 9; % (number of segments - 1)

alpha_stall_w = 11.4; % wing stall angle

[alpha_deg, L_wing_max] = Max_Lift(N, alpha_stall_w);

% Horizontal tail twist angle is zero (deg)
alpha_0_h = 0; % Horizontal tail zero lift angle of attack (deg)
alpha = alpha_deg + alpha_h;

[CL, CL1, y_s, CL_horizontal_tail] = liftingLineTheory(N, alpha, alpha_0_h, span_h, C_r_h, C_L_alpha_h, t_h, AR_h);

% Plot the lift distribution
figure;
plot(y_s,CL1,'-o')
grid
title('Horizontal tail max lift distribution')
xlabel('Semi-span location (m)')
ylabel ('Lift coefficient')

fprintf('The lifting theory horizontal tail lift coefficient is %f\n', CL_horizontal_tail);

% Max lift generated by horizontal tail

rho = 1.225; % air density (kg/m^3)
V = 89.408; % velocity (m/s)

L_tail_max = 0.5 * rho * V^2 * S_h * CL_horizontal_tail;

fprintf('The max lift generated by the horizontal tail is %f N\n', L_tail_max);

% Calculate the lift force at each segment
L = 0.5 * rho * V^2 * S_h .* CL1;

% Plot the lift force distribution
figure;
plot(y_s, L, '-o', 'LineWidth', 2)
grid
set(gca, 'FontSize', 30, 'LineWidth', 2)
xlabel('Semi-span location (m)', 'FontSize', 30)
ylabel('Lift force (N)', 'FontSize', 30)

%% Calculate vertical tail lift force
% Source: CS-VLA Amendement 1, 2009, Appendix B, Figure A4

% W_bar - average vertical tail loading lb/ft^2
if (L_wing_max/(0.7374*9.81))*0.205 < 47 && AR_h < 2
    W_bar_max = 1.656*(L_wing_max/(0.7374*9.81))^0.5;
else
    W_bar_max = 0.109*(L_wing_max/(0.7374*9.81));
end

% Convert W_bar to N/m^2
W_bar_max = W_bar_max * 47.8803;

% Find total lift force
L_v_tail_max = W_bar_max * S_v;

fprintf('The average max lift generated by the vertical tail is %f N\n', L_v_tail_max);
% Conservatively assume max load case is for a gust correction when travelling at maximum speed and an altitude of 0m
% Max lift coefficient of vertical tail
CL_v_tail_max = L_v_tail_max / (0.5 * rho * V^2 * S_v);


% Verify result using lifting line theory

% Vertical tail twist angle is zero (deg)
alpha_0_v = 0; % Horizontal tail zero lift angle of attack (deg)
alpha_v = 12.5; % Vertical tail maximum angle of attack (deg)

[CL_v, CL1_v, y_s_v, CL_vertical_tail] = liftingLineTheory(N, alpha_v, alpha_0_v, span_v*2, C_r_v, C_L_alpha_h, t_v, AR_v);

% Plot the lift distribution
figure;
plot(y_s_v,CL1_v,'-o')
grid
title('Vertical tail max lift distribution')
xlabel('Semi-span location (m)')
ylabel ('Lift coefficient')

fprintf('The lifting theory vertical tail lift coefficient is %f\n', CL_vertical_tail);

% Conservatively assume max load case is for a gust correction when travelling at maximum speed and an altitude of 0m
% Max lift generated by vertical tail

L_l_tail_v_max = 0.5 * rho * V^2 * S_v * CL_vertical_tail;

fprintf('The lifting theory max lift generated by the vertical tail is %f N\n', L_l_tail_v_max);

if L_l_tail_v_max > L_v_tail_max
    fprintf('The vertical tail max lift can be taken as %f N\n', L_v_tail_max);

% Iteratively adjust tail setting angle to match required lift coefficient

% Define the initial guesses for i_t_v
i_t_v_0 = alpha_v;
i_t_v_1 = 0;

% Define the tolerance for the difference between CL_v_tail_max and CL_vertical_tail
tolerance = abs(0.1 * CL_v_tail_max);

% Define the initial values for CL_v_tail_max and CL_vertical_tail
CL_vertical_tail_0 = CL_vertical_tail;
CL_v_tail_max_0 = CL_v_tail_max;

% Calculate the new values for C_l_h and CL_horizontal_tail
N = 9; % (number of segments - 1)
% Horizontal tail twist angle is zero (deg)
alpha_0_v = 0; % Horizontal tail zero lift angle of attack (deg)

theta = pi/(2*N):pi/(2*N):pi/2;
alpha = i_t_v_1;
% segment’s angle of attack
z = (span_v)*cos(theta);
c = C_r_v * (1 - (1-t_v)*cos(theta)); % Mean Aerodynamics Chord at each segment (m)
mu = c * C_L_alpha_h / (4 * (span_v*2));
LHS = mu .* (alpha-alpha_0_v)/57.3; % Left Hand Side
% Solving N equations to find coefficients A(i):
for i=1:N
    for j=1:N
        B(i,j) = sin((2*j-1) * theta(i)) * (1 + (mu(i) * (2*j-1)) /sin(theta(i)));
    end
end
A=B\transpose(LHS);

CL_vertical_tail_1 = pi * AR_v * A(1); % initial value of CL_vertical_tail_1

% Iteratively adjust i_t_v
while true
    % Calculate i_t_h using the secant method
    i_t_v = i_t_v_1 - (CL_vertical_tail - CL_v_tail_max) * (i_t_v_1 - i_t_v_0) / (CL_vertical_tail_1 - CL_vertical_tail_0);

    % Calculate the new values for C_l_h and CL_horizontal_tail
    N = 9; % (number of segments - 1)
    % Horizontal tail twist angle is zero (deg)
    alpha_0_v = 0; % Horizontal tail zero lift angle of attack (deg)
    
    theta = pi/(2*N):pi/(2*N):pi/2;
    alpha = i_t_v;
    % segment’s angle of attack
    z = (span_v)*cos(theta);
    c = C_r_h * (1 - (1-t_h)*cos(theta)); % Mean Aerodynamics Chord at each segment (m)
    mu = c * C_L_alpha_h / (4 * (span_v*2));
    LHS = mu .* (alpha-alpha_0_v)/57.3; % Left Hand Side
    % Solving N equations to find coefficients A(i):
    for i=1:N
        for j=1:N
            B(i,j) = sin((2*j-1) * theta(i)) * (1 + (mu(i) * (2*j-1)) /sin(theta(i)));
        end
    end
    A=B\transpose(LHS);

    CL_vertical_tail = pi * AR_v * A(1);

    % Check if the difference between C_l_h and CL_horizontal_tail is within the tolerance
    if abs(CL_v_tail_max - CL_vertical_tail) <= tolerance
        break;
    end

    % Update i_t_h_0, i_t_h_1, CL_horizontal_tail_0, and CL_horizontal_tail_1 for the next iteration
    i_t_v_0 = i_t_v_1;
    i_t_v_1 = i_t_v;
    CL_vertical_tail_0 = CL_vertical_tail_1;
    CL_vertical_tail_1 = CL_vertical_tail;
end

fprintf(' The vertical tail lift coefficient should be %f\n', CL_v_tail_max);
fprintf('The vertical tail max lift coefficent is calculated as %f N\n', CL_vertical_tail);
fprintf('The equivalent vertical tail setting angle is %f degrees\n', i_t_v);

% Calculate the lift force at each segment
[~, CL1, y_s_v, ~] = liftingLineTheory(N, alpha, alpha_0_v, span_v*2, C_r_v, C_L_alpha_h, t_v, AR_v);
L_v = 0.5 * rho * V^2 * S_v .* CL1;


else
    fprintf('The vertical tail max lift can be taken as %f N\n', L_l_tail_v_max);
    % Calculate the lift force at each segment
L_v = 0.5 * rho * V^2 * S_v .* CL1_v;
end




%% Chord wise lift distribution

% Load the data
upper_data_struct = load('NACA_0012_upper.mat');
lower_data_struct = load('NACA_0012_lower.mat');

% Extract the data from the structures
upper_data = upper_data_struct.NACA_0012_upper;
lower_data = lower_data_struct.NACA0012pressuredistributionmax1;

% Extract x/C and Cp data
x_over_C_upper = upper_data(:, 1);
Cp_upper = upper_data(:, 2);
x_over_C_lower = lower_data(:, 1);
Cp_lower = lower_data(:, 2);

% Plot the pressure distributions
figure(4);
subplot(1,2,1);
plot(x_over_C_upper, Cp_upper, 'b-', x_over_C_lower, Cp_lower, 'r-', 'LineWidth', 2);
set(gca, 'FontSize', 30, 'LineWidth', 2);
xlabel('x/C', 'FontSize', 30);
ylabel('Pressure Coefficient, Cp', 'FontSize', 30);
Y_legend = legend('Upper Surface', 'Lower Surface');
set(Y_legend, 'FontSize', 30);
grid on;

% Define the x values at which to evaluate the interpolated function
x_interp = linspace(min(x_over_C_upper), max(x_over_C_upper), 100);

% Interpolate the data
Cp_interp_upper = interp1(x_over_C_upper, Cp_upper, x_interp, 'pchip');
Cp_interp_lower = interp1(x_over_C_lower, Cp_lower, x_interp, 'pchip');

% Plot the pressure distributions and the interpolated curves
figure;
plot(x_over_C_upper, Cp_upper, 'b-', x_over_C_lower, Cp_lower, 'r-');
hold on;
plot(x_interp, Cp_interp_upper, 'b--', x_interp, Cp_interp_lower, 'r--');
xlabel('x/C');
ylabel('Pressure Coefficient, Cp');
title('Pressure Distribution on NACA 0012 Airfoil');
legend('Upper Surface', 'Lower Surface', 'Interp Upper', 'Interp Lower');
grid on;

% Calculate the chord wise lift coefficient distribution

% Define the number of chord segments
num_segments = 100;

% Define the chord segments
x_segments = linspace(min(x_over_C_upper), max(x_over_C_upper), num_segments+1);

% Initialize the lift coefficient array
CL = zeros(1, num_segments);

% Compute the lift coefficient for each chord segment
for i = 1:num_segments
    % Define the x values for the current segment
    x_segment = x_segments(i):0.001:x_segments(i+1);
    
    % Interpolate the pressure coefficient at these points
    Cp_segment_upper = interp1(x_over_C_upper, Cp_upper, x_segment, 'pchip');
    Cp_segment_lower = interp1(x_over_C_lower, Cp_lower, x_segment, 'pchip');
    
    % Compute the integrals of the interpolated pressure coefficient over the segment
    integral_upper = trapz(x_segment, Cp_segment_upper);
    integral_lower = trapz(x_segment, Cp_segment_lower);
    
    % Compute the lift coefficient for the current segment
    CL(i) = -1*(integral_upper - integral_lower);
end

% Plot the lift coefficient chord-wise distribution
figure;
plot(x_segments(1:end-1), CL, 'b-');
xlabel('x/C');
ylabel('Lift Coefficient, CL');
title('Lift Coefficient Chord-wise Distribution on NACA 0012 Airfoil');
grid on;

% Calculate the chord wise lift force distribution

% Compute the dynamic pressure
q = 0.5 * rho * V^2;

% Initialize the lift force array
L_c = zeros(1, num_segments);

% Compute the lift force for each chord segment
for i = 1:num_segments
    % Compute the chord length of the current segment
    chord_length = x_segments(i+1) - x_segments(i);
    
    % Compute the lift force for the current segment
    L_c(i) = CL(i) * q * chord_length;
end

% Plot the lift force chord-wise distribution
figure(4);
subplot(1,2,2);
plot(x_segments(1:end-1), L_c, 'b-', 'LineWidth', 2);
set(gca, 'FontSize', 30, 'LineWidth', 2);
xlabel('x/C', 'FontSize', 30);
ylabel('Lift Force, L (N)', 'FontSize', 30);
grid on;

% Calculate the total lift force

% Compute the integrals of the interpolated pressure coefficient over x/C
integral_upper = trapz(x_interp, Cp_interp_upper);
integral_lower = trapz(x_interp, Cp_interp_lower);

% Compute the lift coefficient
CL_0012_15 = integral_upper - integral_lower;

fprintf('The NACA 0012 lift coefficient at 15 degrees AoA is %f\n', CL_0012_15);

%% Combine lift distributions into 3D plot

% Convert span wise distributions to interpolated functions with resolution matching the chord wise distribution

% Vertical tail
% Define the y values at which to evaluate the interpolated function
y_interp = linspace(min(y_s_v), max(y_s_v), num_segments);

% Convert to double type
CL1_v = double(CL1_v);
L_v = double(L_v);
y_s_v = double(y_s_v);
y_interp = double(y_interp);

% Interpolate the lift coefficient and lift force
CL1_v_interp = interp1(y_s_v, CL1_v, y_interp, 'pchip');
L_v_interp = interp1(y_s_v, L_v, y_interp, 'pchip');

% Plot the interpolated lift coefficient distribution
figure;
plot(y_interp, CL1_v_interp, '-o')
grid
title('Interpolated Vertical Tail Max Lift Coefficient Distribution')
xlabel('Semi-span location (m)')
ylabel('Lift coefficient')

% Plot the interpolated lift force distribution
figure;
plot(y_interp, L_v_interp, '-o')
grid
title('Interpolated Vertical Tail Lift Force Distribution')
xlabel('Semi-span location (m)')
ylabel('Lift force (N)')

% Horizontal tail
% Define the y values at which to evaluate the interpolated function
y_interp_h = linspace(min(y_s), max(y_s), num_segments);

% Convert to double type
CL1 = double(CL1);
L = double(L);
y_s = double(y_s);
y_interp_h = double(y_interp_h);

% Interpolate the lift coefficient and lift force
CL1_h_interp = interp1(y_s, CL1, y_interp_h, 'pchip');
L_h_interp = interp1(y_s, L, y_interp_h, 'pchip');

% Plot the interpolated lift coefficient distribution
figure;
plot(y_interp_h, CL1_h_interp, '-o')
grid
title('Interpolated Horizontal Tail Max Lift Coefficient Distribution')
xlabel('Semi-span location (m)')
ylabel('Lift coefficient')

% Plot the interpolated lift force distribution
figure;
plot(y_interp_h, L_h_interp, '-o')
grid
title('Interpolated Horizontal Tail Lift Force Distribution')
xlabel('Semi-span location (m)')
ylabel('Lift force (N)')

% 3D plot

% Horizontal tail
% Define the root chord length, taper ratio, and span
% Initialize the lift distribution matrix
L_3D_h = zeros(length(y_interp_h), length(x_segments(1:end-1)));

% Initialize the x-grid
x_grid = zeros(size(L_3D_h));

% Compute the lift distribution
for i = 1:length(y_interp_h)
    % Compute the chord length at the current span-wise point
    C_3d_h = C_r_h - (C_r_h * ((2*y_interp_h(i)/span_h) * (1 - t_h)));

    % Scale the corresponding row of the x-grid
    x_grid(i, :) = x_segments(1:end-1) * C_3d_h;

    % Limitation - not scaled in y as no effect on calculation - however, in reality, it would change reynolds number. Difference is ignored in this case.

    % Calculate the overall lift force for the current span-wise point
    L_c_scaled = L_c * L_h_interp(i);
    
    % Store the scaled lift distribution in the matrix
    L_3D_h(i, :) = fliplr(L_c_scaled);
    
end

x_grid = transpose(x_grid);
x_grid = C_r_h-x_grid;
x_grid = double(x_grid);
L_3D_h = transpose(L_3D_h);

% Create a grid of y values
[y_grid, ~] = meshgrid(y_interp_h, x_segments(1:end-1));

% Create a 3D plot of the lift distribution
figure;
surf(x_grid, y_grid, L_3D_h);
set(gca, 'FontSize', 30, 'LineWidth', 2);
xlabel('Chord-wise location (x)', 'FontSize', 30);
ylabel('Span-wise location (y)', 'FontSize', 30);
zlabel('Lift force (N)', 'FontSize', 30);

% Create a subplot to show different angles
% Create a 3D plot of the lift distribution
figure;
subplot(1,2,1);
surf(x_grid, y_grid, L_3D_h);
set(gca, 'FontSize', 24, 'LineWidth', 1.5);
xlabel('Chord-wise location (x)', 'FontSize', 24);
ylabel('Span-wise location (y)', 'FontSize', 24);
zlabel('Lift force (N)', 'FontSize', 24);
subplot(1,2,2);
surf(x_grid, y_grid, L_3D_h);
set(gca, 'FontSize', 24, 'LineWidth', 1.5);
xlabel('Chord-wise location (x)', 'FontSize', 24);
ylabel('Span-wise location (y)', 'FontSize', 24);
zlabel('Lift force (N)', 'FontSize', 24);


% Create a grid of y values
[x_grid, y_grid] = meshgrid(x_segments(1:end-1), y_interp_h);

% Create a function that interpolates the lift distribution
L_interp_h = @(x, y) interp2(x_grid, y_grid, L_3D_h, x, y, 'spline');

% Vertical tail
% Initialize the lift distribution matrix
L_3D_v = zeros(length(y_interp), length(x_segments) - 1);

% Compute the lift distribution
for i = 1:length(y_interp)
    % Compute the chord length at the current span-wise point
    C_3d_v = C_r_v * (1 - (2*y_interp(i)/span_v) * (1 - t_v));

    % Scale the corresponding row of the x-grid
    x_grid(i, :) = x_segments(1:end-1) * C_3d_v;
    
    % Scale the chord-wise lift distribution
    L_v_scaled = L_c * L_v_interp(i);
    
    % Store the scaled lift distribution in the matrix
    L_3D_v(i, :) = fliplr(L_v_scaled);
    

end

x_grid = transpose(x_grid);
x_grid = C_r_v-x_grid;
x_grid = double(x_grid);
L_3D_v = transpose(L_3D_v);

% Create a grid of y values
[y_grid, ~] = meshgrid(y_interp, x_segments(1:end-1));

% Create a 3D plot of the lift distribution
figure;
surf(L_3D_v, x_grid, y_grid, L_3D_v);
set(gca, 'FontSize', 30, 'LineWidth', 2);
xlabel('Lift force (N)', 'FontSize', 30);
ylabel('Chord-wise location (x)', 'FontSize', 30);
zlabel('Span-wise location (z)', 'FontSize', 30);

